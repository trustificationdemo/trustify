use crate::{
    Error,
    advisory::model::AdvisoryHead,
    purl::model::{BasePurlHead, details::purl::StatusContext, summary::purl::PurlSummary},
    sbom::model::SbomHead,
};
use ::cpe::uri::OwnedUri;
use sea_orm::{
    ColumnTrait, ConnectionTrait, DbBackend, DbErr, EntityTrait, FromQueryResult, LoaderTrait,
    ModelTrait, PaginatorTrait, QueryFilter, QueryResult, QuerySelect, RelationTrait, Select,
    Statement,
};
use sea_query::{Asterisk, Expr, Func, JoinType, SimpleExpr};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use trustify_common::{
    db::{
        VersionMatches,
        multi_model::{FromQueryResultMultiModel, SelectIntoMultiModel},
    },
    memo::Memo,
    purl::Purl,
};
use trustify_cvss::cvss3::{Cvss3Base, score::Score, severity::Severity};
use trustify_entity::{
    advisory, advisory_vulnerability, base_purl, cpe, cvss3, organization,
    package_relates_to_package, purl_status, qualified_purl, relationship::Relationship, sbom,
    sbom_node, sbom_package, sbom_package_purl_ref, status, version_range, versioned_purl,
    vulnerability,
};
use utoipa::ToSchema;
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryHead {
    #[serde(flatten)]
    pub head: AdvisoryHead,
    #[schema(required)]
    pub severity: Option<Severity>,
    #[schema(required)]
    pub score: Option<f64>,
}

impl VulnerabilityAdvisoryHead {
    pub async fn from_entity<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        advisory_vulnerability: &advisory_vulnerability::Model,
        tx: &C,
    ) -> Result<Self, Error> {
        let cvss3 = cvss3::Entity::find()
            .filter(cvss3::Column::AdvisoryId.eq(advisory_vulnerability.advisory_id))
            .filter(cvss3::Column::VulnerabilityId.eq(&vulnerability.id))
            .all(tx)
            .await?;

        let score = if cvss3.is_empty() {
            None
        } else {
            Some(Score::from_iter(cvss3.iter().map(Cvss3Base::from)))
        };

        if let Some(advisory) = &advisory_vulnerability
            .find_related(advisory::Entity)
            .one(tx)
            .await?
        {
            Ok(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, Memo::NotProvided, tx).await?,
                severity: score.map(|score| score.severity()),
                score: score.map(|score| score.value()),
            })
        } else {
            Err(Error::Data("Underlying advisory is missing".to_string()))
        }
    }
    pub async fn from_entities<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        vuln_advisories: &[advisory::Model],
        vuln_cvss3s: &[cvss3::Model],
        tx: &C,
    ) -> Result<Vec<Self>, Error> {
        let mut heads = Vec::new();

        let organizations = vuln_advisories.load_one(organization::Entity, tx).await?;

        for (advisory, issuer) in vuln_advisories.iter().zip(organizations.into_iter()) {
            // filter all vulnerability cvss3 to those that pertain to only this advisory.
            let cvss3 = vuln_cvss3s
                .iter()
                .filter(|e| e.vulnerability_id == vulnerability.id)
                .collect::<Vec<_>>();

            let score = if cvss3.is_empty() {
                None
            } else {
                Some(Score::from_iter(cvss3.into_iter().map(Cvss3Base::from)))
            };

            heads.push(VulnerabilityAdvisoryHead {
                head: AdvisoryHead::from_advisory(advisory, Memo::Provided(issuer), tx).await?,
                severity: score.map(|score| score.severity()),
                score: score.map(|score| score.value()),
            });
        }

        Ok(heads)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisorySummary {
    #[serde(flatten)]
    pub head: VulnerabilityAdvisoryHead,

    /// CVSS3 scores from this advisory regarding the vulnerability.
    #[schema(default, value_type = Vec < String >)]
    pub cvss3_scores: Vec<String>,

    pub purls: HashMap<String, Vec<VulnerabilityAdvisoryStatus>>,

    /// SBOMs claimed by this advisory to be addressed by this vulnerability.
    pub sboms: Vec<VulnerabilitySbomStatus>,

    /// The total number of vulnerabilities described by this advisory
    pub number_of_vulnerabilities: u64,
}

impl VulnerabilityAdvisorySummary {
    pub async fn from_entities<C: ConnectionTrait>(
        vulnerability: &vulnerability::Model,
        advisory_vulnerabilities: &[advisory_vulnerability::Model],
        vuln_cvss3: &[cvss3::Model],
        tx: &C,
    ) -> Result<Vec<Self>, Error> {
        let purl_status_query = purl_status::Entity::find()
            .left_join(status::Entity)
            .filter(purl_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .left_join(base_purl::Entity)
            .left_join(version_range::Entity)
            .left_join(cpe::Entity);

        let sbom_status_query = sbom_package_purl_ref::Entity::find()
            .join(JoinType::Join, sbom_package_purl_ref::Relation::Purl.def())
            .join(
                JoinType::Join,
                qualified_purl::Relation::VersionedPurl.def(),
            )
            .join(JoinType::Join, versioned_purl::Relation::BasePurl.def())
            .join(JoinType::Join, base_purl::Relation::PurlStatus.def())
            .join(JoinType::Join, purl_status::Relation::Status.def())
            .join(JoinType::Join, purl_status::Relation::VersionRange.def())
            .join(JoinType::Join, sbom_package_purl_ref::Relation::Sbom.def())
            .join(JoinType::Join, sbom::Relation::SbomNode.def())
            .join(JoinType::Join, sbom_node::Relation::DescribesSbom.def())
            .join(
                JoinType::Join,
                package_relates_to_package::Relation::RightPackage.def(),
            )
            .filter(purl_status::Column::VulnerabilityId.eq(&vulnerability.id))
            .filter(status::Column::Slug.ne("not_affected"))
            .filter(SimpleExpr::FunctionCall(
                Func::cust(VersionMatches)
                    .arg(Expr::col((
                        versioned_purl::Entity,
                        versioned_purl::Column::Version,
                    )))
                    .arg(Expr::col((version_range::Entity, Asterisk))),
            ))
            .select_only()
            .column(purl_status::Column::AdvisoryId);

        let mut vuln_sbom_statuses = sbom_status_query
            .try_into_multi_model::<SbomStatusCatcher>()?
            .all(tx)
            .await?;

        // The query for now is in the raw form for couple of reasons
        // First some of the join are not easily (or at all) doable using sea-orm concepts
        // Second, it's much easier to iterate over query and work on it in this form
        // than using the code
        // It might be a good practice to start like this for complex query logic and
        // turn it into a code once things stabilize
        let product_status_query = r#"
            SELECT
                "product_status"."advisory_id",
                "sbom_package_purl_ref"."sbom_id",
                "sbom_package_purl_ref"."node_id",
                "sbom_package_purl_ref"."qualified_purl_id",
                "sbom"."sbom_id" AS "sbom$sbom_id",
                "sbom"."node_id" AS "sbom$node_id",
                "sbom"."document_id" AS "sbom$document_id",
                "sbom"."published" AS "sbom$published",
                "sbom"."authors" AS "sbom$authors",
                "sbom"."suppliers" AS "sbom$suppliers",
                "sbom"."data_licenses" AS "sbom$data_licenses",
                "sbom"."source_document_id" AS "sbom$source_document_id",
                "sbom"."labels" AS "sbom$labels",
                "sbom_package"."sbom_id" AS "sbom_package$sbom_id",
                "sbom_package"."node_id" AS "sbom_package$node_id",
                "sbom_package"."version" AS "sbom_package$version",
                "sbom_node"."sbom_id" AS "sbom_node$sbom_id",
                "sbom_node"."node_id" AS "sbom_node$node_id",
                "sbom_node"."name" AS "sbom_node$name",
                "status"."id" AS "status$id",
                "status"."slug" AS "status$slug",
                "status"."name" AS "status$name",
                "status"."description" AS "status$description",
                "qualified_purl"."id" AS "qualified_purl$id",
                "qualified_purl"."versioned_purl_id" AS "qualified_purl$versioned_purl_id",
                "qualified_purl"."qualifiers" AS "qualified_purl$qualifiers",
                "qualified_purl"."purl" AS "qualified_purl$purl"
            FROM "product_status"
            JOIN "cpe" ON "product_status"."context_cpe_id" = "cpe"."id"
            JOIN "status" ON "product_status"."status_id" = "status"."id"

            -- find all related products and versions
            JOIN "product" ON "cpe"."product" = "product"."cpe_key"
            JOIN "product_version" ON "product"."id" = "product_version"."product_id"
            JOIN "product_version_range" ON "product_status"."product_version_range_id" = "product_version_range"."id"
            JOIN "version_range" ON "product_version_range"."version_range_id" = "version_range"."id" AND version_matches("product_version"."version", "version_range".*)

            -- find all sboms matching product versions
            JOIN "sbom" ON "product_version"."sbom_id" = "sbom"."sbom_id"

            -- find purls belonging to the sboms having a name matching package patterns
            JOIN base_purl on "product_status"."package" LIKE CONCAT("base_purl"."namespace", '/', "base_purl"."name") OR "product_status"."package" = "base_purl"."name"
            JOIN "versioned_purl" ON "versioned_purl"."base_purl_id" = "base_purl"."id"
            JOIN "qualified_purl" ON "qualified_purl"."versioned_purl_id" = "versioned_purl"."id"
            JOIN sbom_package_purl_ref on sbom_package_purl_ref.qualified_purl_id = qualified_purl.id AND sbom_package_purl_ref.sbom_id = sbom.sbom_id

            -- get basic sbom info; name and version
            JOIN "sbom_node" ON "sbom"."sbom_id" = "sbom_node"."sbom_id" AND "sbom_node"."node_id" = "sbom"."node_id"
            JOIN package_relates_to_package on package_relates_to_package.sbom_id = sbom_node.sbom_id AND relationship = $2
            JOIN sbom_package on sbom_package.sbom_id = package_relates_to_package.sbom_id AND sbom_package.node_id = package_relates_to_package.right_node_id

            WHERE
            "product_status"."vulnerability_id" = $1 AND "product_status"."package" IS NOT NULL and status.slug != 'not_affected'
            "#;

        let result: Vec<QueryResult> = tx
            .query_all(Statement::from_sql_and_values(
                DbBackend::Postgres,
                product_status_query,
                [
                    vulnerability.id.clone().into(),
                    Relationship::Describes.into(),
                ],
            ))
            .await?;

        vuln_sbom_statuses.extend(
            result
                .iter()
                .map(|row| SbomStatusCatcher::from_query_result(row, ""))
                .collect::<Result<Vec<_>, _>>()?,
        );

        // Purl statuses might make sense only when we don't have any sboms
        // so we can show what we know about affected purls
        // It's a legacy at this point as some tests depends on it,
        // but they don't make too much sense with the current APIs
        // We need to revisit this in the future as it's affecting performance without
        // too much benefit.
        let mut vuln_purl_statuses = Vec::new();
        if vuln_sbom_statuses.is_empty() {
            vuln_purl_statuses = purl_status_query
                .try_into_multi_model::<PurlStatusCatcher>()?
                .all(tx)
                .await?;
        }

        let mut summaries = Vec::new();

        for advisory_vulnerability in advisory_vulnerabilities {
            let number_of_vulnerabilities = advisory_vulnerability
                .find_linked(advisory_vulnerability::AdvisoryVulnerabilityToAdvisoryVulnerabilities)
                .count(tx)
                .await?;

            let cvss3_scores = vuln_cvss3
                .iter()
                .filter(|e| e.advisory_id == advisory_vulnerability.advisory_id)
                .map(|e| Cvss3Base::from(e.clone()).to_string())
                .collect();

            let sbom_statuses = vuln_sbom_statuses
                .iter()
                .filter(|e| e.advisory_id == advisory_vulnerability.advisory_id);

            let purl_statuses = vuln_purl_statuses
                .iter()
                .filter(|e| e.purl_status.advisory_id == advisory_vulnerability.advisory_id);

            summaries.push(VulnerabilityAdvisorySummary {
                head: VulnerabilityAdvisoryHead::from_entity(
                    vulnerability,
                    advisory_vulnerability,
                    tx,
                )
                .await?,
                cvss3_scores,
                purls: VulnerabilityAdvisoryStatus::from_models(purl_statuses).await?,
                sboms: VulnerabilitySbomStatus::from_models(sbom_statuses, tx).await?,
                number_of_vulnerabilities,
            });
        }

        Ok(summaries)
    }
}

#[derive(Debug)]
struct PurlStatusCatcher {
    status: status::Model,
    purl_status: purl_status::Model,
    version_range: version_range::Model,
    cpe: Option<cpe::Model>,

    base_purl: base_purl::Model,
}

impl FromQueryResult for PurlStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            status: Self::from_query_result_multi_model(res, "", status::Entity)?,
            purl_status: Self::from_query_result_multi_model(res, "", purl_status::Entity)?,
            version_range: Self::from_query_result_multi_model(res, "", version_range::Entity)?,
            cpe: Self::from_query_result_multi_model_optional(res, "", cpe::Entity)?,
            base_purl: Self::from_query_result_multi_model(res, "", base_purl::Entity)?,
        })
    }
}

impl FromQueryResultMultiModel for PurlStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns(status::Entity)?
            .try_model_columns(purl_status::Entity)?
            .try_model_columns(version_range::Entity)?
            .try_model_columns(cpe::Entity)?
            .try_model_columns(base_purl::Entity)
    }
}

impl PurlStatusCatcher {
    pub fn purl(&self) -> Purl {
        Purl {
            ty: self.base_purl.r#type.clone(),
            namespace: self.base_purl.namespace.clone(),
            name: self.base_purl.name.clone(),
            version: None,
            qualifiers: Default::default(),
        }
    }

    pub fn version(&self) -> String {
        match (
            &self.version_range.low_version,
            &self.version_range.high_version,
        ) {
            (Some(low), Some(high)) if low == high => low.clone(),
            (Some(low), Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }

            (Some(low), None) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push_str(low);
                v.push(',');
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }
            (None, Some(high)) => {
                let mut v = String::new();
                v.push(Self::open_delim(self.version_range.low_inclusive));
                v.push(',');
                v.push_str(high);
                v.push(Self::close_delim(self.version_range.high_inclusive));
                v
            }
            (None, None) => "*".to_string(),
        }
    }

    fn open_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl { '[' } else { '(' }
        } else {
            '('
        }
    }

    fn close_delim(incl: Option<bool>) -> char {
        if let Some(incl) = incl {
            if incl { ']' } else { ')' }
        } else {
            ')'
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
pub struct VulnerabilityAdvisoryStatus {
    pub base_purl: BasePurlHead,
    pub version: String,
    #[schema(required)]
    pub context: Option<StatusContext>,
}

impl VulnerabilityAdvisoryStatus {
    async fn from_models<'i, I: Iterator<Item = &'i PurlStatusCatcher>>(
        purls: I,
    ) -> Result<HashMap<String, Vec<Self>>, Error> {
        let mut statuses = HashMap::new();

        for each in purls {
            let context = each.cpe.as_ref().and_then(|cpe| {
                let cpe: Result<OwnedUri, _> = cpe.try_into();
                cpe.ok().map(|cpe| StatusContext::Cpe(cpe.to_string()))
            });

            let status_entry = statuses.entry(each.status.slug.clone()).or_insert(vec![]);
            status_entry.push(VulnerabilityAdvisoryStatus {
                base_purl: BasePurlHead {
                    uuid: each.base_purl.id,
                    purl: each.purl(),
                },
                version: each.version(),
                context,
            });
        }

        Ok(statuses)
    }
}

#[derive(Debug)]
struct SbomStatusCatcher {
    advisory_id: Uuid,
    sbom: sbom::Model,
    sbom_package: sbom_package::Model,
    sbom_node: sbom_node::Model,
    status: status::Model,
    qualified_purl: qualified_purl::Model,
}

impl FromQueryResult for SbomStatusCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            advisory_id: res.try_get("", "advisory_id")?,
            sbom: Self::from_query_result_multi_model(res, "", sbom::Entity)?,
            sbom_package: Self::from_query_result_multi_model(res, "", sbom_package::Entity)?,
            sbom_node: Self::from_query_result_multi_model(res, "", sbom_node::Entity)?,
            status: Self::from_query_result_multi_model(res, "", status::Entity)?,
            qualified_purl: Self::from_query_result_multi_model(res, "", qualified_purl::Entity)?,
        })
    }
}

impl FromQueryResultMultiModel for SbomStatusCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select
            .try_model_columns(sbom::Entity)?
            .try_model_columns(sbom_package::Entity)?
            .try_model_columns(sbom_node::Entity)?
            .try_model_columns(status::Entity)?
            .try_model_columns(base_purl::Entity)?
            .try_model_columns(versioned_purl::Entity)?
            .try_model_columns(qualified_purl::Entity)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, ToSchema)]
pub struct VulnerabilitySbomStatus {
    #[serde(flatten)]
    pub head: SbomHead,

    pub version: Option<String>,

    pub purl_statuses: HashMap<String, HashSet<PurlSummary>>,
}

impl VulnerabilitySbomStatus {
    async fn from_models<'i, 'j, I, C>(sbom_purl_status: I, tx: &C) -> Result<Vec<Self>, Error>
    where
        I: Iterator<Item = &'i SbomStatusCatcher> + Clone,
        C: ConnectionTrait,
    {
        let mut sboms = HashMap::new();

        for status in sbom_purl_status.clone() {
            let sbom_status = match sboms.get_mut(&status.sbom.sbom_id) {
                Some(existing_entry) => existing_entry,
                None => {
                    let new_entry = VulnerabilitySbomStatus {
                        head: SbomHead::from_entity(
                            &status.sbom,
                            Some(status.sbom_node.clone()),
                            tx,
                        )
                        .await?,
                        version: status.sbom_package.version.clone(),
                        purl_statuses: Default::default(),
                    };
                    sboms.entry(&status.sbom.sbom_id).or_insert(new_entry)
                }
            };

            let purl_status = sbom_status
                .purl_statuses
                .entry(status.status.slug.clone())
                .or_insert(Default::default());

            purl_status.insert(PurlSummary::from_entity(&status.qualified_purl));
        }

        Ok(sboms.into_values().collect())
    }
}
