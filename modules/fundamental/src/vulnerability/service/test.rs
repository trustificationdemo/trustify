use std::str::FromStr;

use crate::purl::service::PurlService;
use crate::sbom::service::SbomService;
use crate::vulnerability::service::VulnerabilityService;
use test_context::test_context;
use test_log::test;
use trustify_common::db::query::{Query, q};
use trustify_common::model::Paginated;
use trustify_common::purl::Purl;
use trustify_test_context::TrustifyContext;

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn all_vulnerabilities(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vulns = service
        .fetch_vulnerabilities(
            Query::default(),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;

    assert_eq!(1, vulns.items.len());

    assert!(
        vulns.items[0]
            .head
            .description
            .as_ref()
            .unwrap()
            .starts_with("hyper is an HTTP library for Rust")
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2021-32714", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    assert_eq!(2, vuln.advisories.len());

    log::debug!("{vuln:#?}");

    let rustsec_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "RUSTSEC-2021-0079");
    assert!(rustsec_advisory.is_some());
    let rustsec_advisory = rustsec_advisory.unwrap();

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "CVE-2021-32714");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    let rustsec_statuses: Vec<_> = rustsec_advisory.purls.keys().collect();

    assert_eq!(2, rustsec_statuses.len());
    assert!(rustsec_statuses.contains(&&"fixed".to_string()));
    assert!(rustsec_statuses.contains(&&"affected".to_string()));

    let cve_statuses: Vec<_> = cve_advisory.purls.keys().collect();
    assert_eq!(0, cve_statuses.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn statuses_too(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "cve/CVE-2024-29025.json",
        "csaf/rhsa-2024-2705.json",
        "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json",
        "spdx/quarkus-bom-3.2.12.Final-redhat-00002.json",
    ])
    .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(2, vuln.advisories.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn commons_compress(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());

    // Ingest a CVE declaring the vulnerability present in versions
    // [1.21,1.26.0) of commons-compress, along with 2 sboms, each of
    // which includes a vulnerable version of commons-compress
    let ingest_results = ctx
        .ingest_documents([
            "cve/CVE-2024-26308.json",
            "spdx/SATELLITE-6.15-RHEL-8.json", // 1.21
            "spdx/OCP-TOOLS-4.11-RHEL-8.json", // 1.24
            "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json", // 1.26.0.redhat-00001
        ])
        .await?;

    let sat_id = ingest_results[1].id.clone();

    let sat_sbom = sbom_service
        .fetch_sbom_details(sat_id, vec![], &ctx.db)
        .await?;
    assert!(sat_sbom.is_some());

    let sat_sbom = sat_sbom.unwrap();
    assert_eq!(1, sat_sbom.advisories.len());

    let sat_status = &sat_sbom.advisories[0].status[0];

    // first, ensure our assumptions are correct and
    // the pURL is indeed part of the SBOM we think
    // it is.
    assert_eq!(sat_status.status, "affected");

    assert_eq!(1, sat_status.packages.len());

    assert_eq!(
        sat_status.packages[0].purl[0].head.purl.to_string(),
        "pkg:maven/org.apache.commons/commons-compress@1.21"
    );

    let quarkus_id = ingest_results[3].id.clone();

    let quarkus_sbom = sbom_service
        .fetch_sbom_details(quarkus_id, vec![], &ctx.db)
        .await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    // Quarkus should /not/ be affected.
    assert!(quarkus_sbom.advisories.is_empty());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2024-26308", Default::default(), &ctx.db)
        .await?
        .unwrap();

    log::debug!("{vuln:#?}");

    // Collect and sort the SBOMs by their document_id for consistent iteration.
    let mut sboms: Vec<_> = vuln.advisories[0].sboms.iter().collect::<Vec<_>>();
    sboms.sort_by_key(|sbom| sbom.head.document_id.clone().expect("No document id"));

    // Define the expected PURL and version pairs.
    let expected = [
        (
            "https://access.redhat.com/security/data/sbom/spdx/OCP-TOOLS-4.11-RHEL-8",
            "pkg:maven/org.apache.commons/commons-compress",
            "1.24.0",
        ),
        (
            "https://access.redhat.com/security/data/sbom/spdx/SATELLITE-6.15-RHEL-8",
            "pkg:maven/org.apache.commons/commons-compress",
            "1.21",
        ),
    ];

    // Iterate through sorted SBOMs and validate each entry.
    for (sbom, (expected_id, expected_purl, expected_version)) in sboms.iter().zip(&expected) {
        assert_eq!(
            sbom.head.document_id.clone().expect("No document id"),
            *expected_id
        );

        // Get the affected PURL status for the SBOM.
        let purl = sbom.purl_statuses["affected"]
            .iter()
            .next()
            .expect("no purl status");
        assert_eq!(purl.head.purl.to_base().to_string(), *expected_purl);
        assert_eq!(purl.head.purl.version.as_deref(), Some(*expected_version));
    }

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn product_statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());
    let purl_service = PurlService::new();

    let ingest_results = ctx
        .ingest_documents([
            "csaf/cve-2023-0044.json",
            "quarkus/v2/quarkus-bom-2.13.8.Final-redhat-00004.json",
        ])
        .await?;

    let quarkus_id = ingest_results[1].id.clone();

    let quarkus_sbom = sbom_service
        .fetch_sbom_details(quarkus_id, vec![], &ctx.db)
        .await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    log::debug!("{quarkus_sbom:#?}");

    assert!(!quarkus_sbom.advisories.is_empty());
    let quarkus_adv = &quarkus_sbom.advisories[0].status[0];

    assert_eq!(quarkus_adv.status, "affected");
    assert_eq!(quarkus_adv.vulnerability.identifier, "CVE-2023-0044");

    assert_eq!(quarkus_adv.packages.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl[0].head.purl, Purl::from_str("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar").unwrap());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2023-0044", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(1, vuln.advisories.len());

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    log::debug!("{cve_advisory:#?}");

    assert_eq!(
        "pkg:maven/io.quarkus/quarkus-vertx-http",
        cve_advisory.sboms[0].purl_statuses["affected"]
            .clone()
            .into_iter()
            .next()
            .expect("no purl status")
            .head
            .purl
            .to_base()
            .to_string()
    );

    // Ensure that vuln->sbom mapping is good.
    let mut sboms: Vec<_> = vuln.advisories[0]
        .sboms
        .iter()
        .flat_map(|i| i.head.document_id.clone())
        .collect();
    sboms.sort();

    assert_eq!(
        sboms,
        ["https://access.redhat.com/security/data/sbom/spdx/quarkus-bom-2.13.8.Final-redhat-00004",],
    );

    // Ensure that purl->vuln mapping is good
    let purl = purl_service
        .purl_by_purl(
            &Purl::try_from("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar")?,
            Default::default(),
            &ctx.db,
        )
        .await?;

    log::debug!("{:#?}", purl);
    assert!(purl.is_some());
    let purl = purl.unwrap();
    assert_eq!(1, purl.advisories.len());

    let cve_advisory = purl
        .advisories
        .iter()
        .find(|e| e.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn delete_vulnerability(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["cve/CVE-2024-29025.json"]).await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?
        .expect("Vulnerability not found");

    assert_eq!(1, vuln.advisories.len());

    let id = &vuln.advisories[0].head.head.identifier;

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(1, affected);

    assert!(
        service
            .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
            .await?
            .is_none()
    );

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(0, affected);

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn vulnerability_queries(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "csaf/CVE-2023-20862.json",
        "csaf/RHBA-2024_1440.json",
        "csaf/rhsa-2023_5835.json",
    ])
    .await?;

    let vulns = service
        .fetch_vulnerabilities(q(""), Paginated::default(), Default::default(), &ctx.db)
        .await?;
    assert_eq!(5, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("average_score>9"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("average_severity=critical"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("average_severity<high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    tracing::debug!(test = "", "{vulns:#?}");
    assert_eq!(2, vulns.items.len());
    assert_eq!(
        *vulns.items[0].average_severity.as_ref().unwrap(),
        trustify_cvss::cvss3::severity::Severity::Medium
    );
    let vulns = service
        .fetch_vulnerabilities(
            q("average_severity>=high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    tracing::debug!(test = "", "{vulns:#?}");
    assert_eq!(3, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("20862"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-20862");

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(actix_web::test)]
async fn analyze_purls(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "osv/GHSA-2ccf-ffrj-m4qw.json"])
        .await?;

    let result = service.analyze_purls(vec![], &ctx.db).await?;

    assert!(result.is_empty());

    for purl in ["this is not valid", "pkg:npm/missing.version"].iter() {
        let result = service.analyze_purls(vec![purl], &ctx.db).await;
        assert!(result.is_err());
    }

    let expected = [
        "pkg:npm/%40fastify/passport@1.0.0", // ECOSYSTEM:afected
        "pkg:cargo/hyper@0.14.9",            // SEMVER:affected - no namespace
    ];

    let not_found = [
        "pkg:npm/%40fastify/passport@2.3.0", // ECOSYSTEM:fixed
        "pkg:golang/github.com/metal3-io/baremetal-operator/apis@0.8.0", // Missing
        "pkg:cargo/hyper@0.14.11",           // SEMVER:fixed - no namespace
    ];

    let items: Vec<&str> = expected.iter().chain(&not_found).copied().collect();

    let result = service.analyze_purls(items, &ctx.db).await?;

    expected.iter().for_each(|&item| {
        assert!(
            result.contains_key(item),
            "Expected key '{}' not found in result",
            item
        )
    });
    not_found.iter().for_each(|&item| {
        assert!(
            !result.contains_key(item),
            "Unexpected key '{}' found in result",
            item
        )
    });
    Ok(())
}
