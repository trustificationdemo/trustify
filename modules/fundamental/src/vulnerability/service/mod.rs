use std::{collections::HashMap, str::FromStr};

use crate::{
    Error,
    vulnerability::model::{VulnerabilityDetails, VulnerabilitySummary},
};
use futures_util::{TryFutureExt, TryStreamExt};
use sea_orm::{
    EntityTrait, FromQueryResult, IntoIdentity, QuerySelect, QueryTrait, Statement, StreamTrait,
    prelude::*,
};
use sea_query::{ColumnRef, Func, IntoColumnRef, IntoIden, SimpleExpr};
use trustify_common::{
    db::{
        limiter::LimiterAsModelTrait,
        multi_model::{FromQueryResultMultiModel, SelectIntoMultiModel},
        query::{Columns, Filtering, Query},
    },
    model::{Paginated, PaginatedResults},
    purl::{Purl, PurlErr},
};
use trustify_entity::{
    cvss3::{self, Severity},
    vulnerability,
};
use trustify_module_ingestor::common::Deprecation;

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let inner_query = vulnerability::Entity::find()
            .left_join(cvss3::Entity)
            .expr_as_(
                SimpleExpr::FunctionCall(Func::avg(SimpleExpr::Column(
                    trustify_entity::cvss3::Column::Score.into_column_ref(),
                ))),
                "average_score",
            )
            .expr_as_(
                SimpleExpr::FunctionCall(Func::cust("cvss3_severity".into_identity()).arg(
                    SimpleExpr::FunctionCall(Func::avg(SimpleExpr::Column(
                        trustify_entity::cvss3::Column::Score.into_column_ref(),
                    ))),
                )),
                "average_severity",
            )
            .group_by(vulnerability::Column::Id);

        let mut outer_query = vulnerability::Entity::find();

        // Alias the inner query as exactly the table the entity is expecting
        // so that column aliases link up correctly.
        QueryTrait::query(&mut outer_query)
            .from_clear()
            .from_subquery(inner_query.into_query(), "vulnerability".into_identity());

        let limiter = outer_query
            .column_as(
                SimpleExpr::Column(ColumnRef::Column(
                    "average_score".into_identity().into_iden(),
                )),
                "average_score",
            )
            .column_as(
                SimpleExpr::Column(ColumnRef::Column(
                    "average_severity".into_identity().into_iden(),
                ))
                .cast_as("TEXT".into_identity()),
                "average_severity",
            )
            .filtering_with(
                search,
                Columns::from_entity::<vulnerability::Entity>()
                    .add_column("average_score", ColumnType::Decimal(None).def())
                    .add_column(
                        "average_severity",
                        ColumnType::Enum {
                            name: "cvss3_severity".into_identity().into_iden(),
                            variants: vec![
                                "none".into_identity().into_iden(),
                                "low".into_identity().into_iden(),
                                "medium".into_identity().into_iden(),
                                "high".into_identity().into_iden(),
                                "critical".into_identity().into_iden(),
                            ],
                        }
                        .def(),
                    )
                    .translator(|f, op, v| match (f, v) {
                        // v = "" for all sort fields
                        ("average_severity", "") => Some(format!("average_score:{op}")),
                        _ => None,
                    }),
            )?
            .try_limiting_as_multi_model::<VulnerabilityCatcher>(
                connection,
                paginated.offset,
                paginated.limit,
            )?;

        let total = limiter.total().await?;
        let caught = limiter.fetch().await?;
        let vulnerabilities = caught
            .iter()
            .map(|e| e.vulnerability.clone())
            .collect::<Vec<_>>();
        let averages = caught
            .iter()
            .map(|e| (e.average_score, e.average_severity.map(|s| s.into())))
            .collect::<Vec<_>>();

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(
                &vulnerabilities,
                &averages,
                deprecation,
                connection,
            )
            .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }

    pub async fn analyze_purls<C>(
        &self,
        purls: Vec<&str>,
        connection: &C,
    ) -> Result<HashMap<String, Vec<VulnerabilityDetails>>, Error>
    where
        C: ConnectionTrait + StreamTrait,
    {
        let query = purls
            .iter()
            .map(|p| {
                let purl = Purl::from_str(p)?;

                let ns_condition = match &purl.namespace {
                    Some(namespace) => {
                        let sql = "base_purl.namespace = $1";
                        Statement::from_sql_and_values(
                            connection.get_database_backend(),
                            sql,
                            [namespace.into()],
                        )
                    }
                    None => Statement::from_string(
                        connection.get_database_backend(),
                        "base_purl.namespace IS NULL",
                    ),
                };

                let values = [
                    p.to_string().into(),
                    purl.name.into(),
                    purl.ty.into(),
                    purl.version.ok_or_else(|| PurlErr::MissingVersion(p.to_string()))?.into(),
                ];
                let sql = format!(r#"
                  SELECT $1 as requested_purl,
                    vulnerability.id, vulnerability.title, vulnerability.reserved,
                    vulnerability.published, vulnerability.modified, vulnerability.withdrawn, vulnerability.cwes
                  FROM base_purl
                    LEFT JOIN purl_status ON base_purl.id = purl_status.base_purl_id
                    INNER JOIN version_range ON purl_status.version_range_id = version_range.id
                    LEFT JOIN vulnerability ON purl_status.vulnerability_id = vulnerability.id
                    INNER JOIN status ON purl_status.status_id = status.id
                  WHERE {ns_condition}
                    AND base_purl.name = $2
                    AND base_purl.type = $3
                    AND version_matches($4, version_range.*) = TRUE
                    AND status.slug != 'fixed'"#);
                let query =
                    Statement::from_sql_and_values(connection.get_database_backend(), &sql, values);
                Ok(query.to_string())
            })
            .collect::<Result<Vec<String>, Error>>()?
            .join(" UNION ALL ");

        let stmt = Statement::from_string(connection.get_database_backend(), query);
        let result = connection.stream(stmt).map_err(Error::from).await?;
        let result = result
            .map_err(Error::from)
            .and_then(|row| self.to_vuln(row, connection))
            .try_fold(
                HashMap::new(),
                |mut acc: HashMap<String, Vec<VulnerabilityDetails>>,
                 (requested_purl, vuln_details)| async {
                    acc.entry(requested_purl).or_default().push(vuln_details);
                    Ok(acc)
                },
            )
            .await?;

        Ok(result)
    }

    async fn to_vuln<C: ConnectionTrait>(
        &self,
        row: QueryResult,
        connection: &C,
    ) -> Result<(String, VulnerabilityDetails), Error> {
        let requested_purl: String = row.try_get("", "requested_purl")?;
        let vulnerability = vulnerability::Model {
            id: row.try_get("", "id")?,
            title: row.try_get("", "title")?,
            reserved: row.try_get("", "reserved")?,
            published: row.try_get("", "published")?,
            modified: row.try_get("", "modified")?,
            withdrawn: row.try_get("", "withdrawn")?,
            cwes: row.try_get("", "cwes")?,
        };
        let vuln_details =
            VulnerabilityDetails::from_entity(&vulnerability, Deprecation::Ignore, connection)
                .await;
        match vuln_details {
            Ok(details) => Ok((requested_purl, details)),
            Err(e) => Err(e),
        }
    }
}

#[derive(Debug)]
struct VulnerabilityCatcher {
    pub vulnerability: vulnerability::Model,
    pub average_score: Option<f64>,
    pub average_severity: Option<Severity>,
}

impl FromQueryResult for VulnerabilityCatcher {
    fn from_query_result(res: &QueryResult, _pre: &str) -> Result<Self, DbErr> {
        Ok(Self {
            vulnerability: Self::from_query_result_multi_model(res, "", vulnerability::Entity)?,
            average_score: res.try_get("", "average_score")?,
            average_severity: res.try_get("", "average_severity")?,
        })
    }
}

impl FromQueryResultMultiModel for VulnerabilityCatcher {
    fn try_into_multi_model<E: EntityTrait>(select: Select<E>) -> Result<Select<E>, DbErr> {
        select.try_model_columns(vulnerability::Entity)
    }
}

#[cfg(test)]
mod test;
