//! Support for CVEs.

use crate::common::{Deprecation, DeprecationExt};
use crate::{graph::Graph, graph::advisory::AdvisoryContext, graph::error::Error};
use sea_orm::{
    ActiveValue::Set, ColumnTrait, ConnectionTrait, EntityTrait, ModelTrait, QueryFilter,
    QuerySelect, RelationTrait,
};
use sea_query::{JoinType, OnConflict};
use std::fmt::{Debug, Formatter};
use time::OffsetDateTime;
use tracing::instrument;
use trustify_common::db::chunk::EntityChunkedIter;
use trustify_entity::{advisory, advisory_vulnerability, vulnerability, vulnerability_description};
use uuid::Uuid;

#[derive(Clone, Default, Debug)]
pub struct VulnerabilityInformation {
    pub title: Option<String>,
    pub reserved: Option<OffsetDateTime>,
    pub published: Option<OffsetDateTime>,
    pub modified: Option<OffsetDateTime>,
    pub withdrawn: Option<OffsetDateTime>,
    pub cwes: Option<Vec<String>>,
}

impl VulnerabilityInformation {
    pub fn has_data(&self) -> bool {
        self.title.is_some()
            || self.reserved.is_some()
            || self.published.is_some()
            || self.modified.is_some()
            || self.withdrawn.is_some()
            || self.cwes.is_some()
    }
}

impl From<()> for VulnerabilityInformation {
    fn from(_: ()) -> Self {
        Self {
            title: None,
            reserved: None,
            published: None,
            modified: None,
            withdrawn: None,
            cwes: None,
        }
    }
}

impl Graph {
    #[instrument(skip(self, db), err(level=tracing::Level::INFO))]
    pub async fn ingest_vulnerability<C: ConnectionTrait>(
        &self,
        identifier: &str,
        information: impl Into<VulnerabilityInformation> + Debug,
        db: &C,
    ) -> Result<VulnerabilityContext, Error> {
        let information = information.into();

        let mut on_conflict = OnConflict::columns([vulnerability::Column::Id]);
        let on_conflict = match information.has_data() {
            true => on_conflict.update_columns([
                vulnerability::Column::Title,
                vulnerability::Column::Reserved,
                vulnerability::Column::Published,
                vulnerability::Column::Modified,
                vulnerability::Column::Withdrawn,
                vulnerability::Column::Cwes,
            ]),
            false => {
                // we "update" the ID column (which actually stays the same) so that we can use the
                // "returning" statement later on with `.exec_with_returning`.
                on_conflict.update_columns([vulnerability::Column::Id])
            }
        }
        .to_owned();

        let entity = vulnerability::ActiveModel {
            id: Set(identifier.to_string()),
            title: Set(information.title),
            reserved: Set(information.reserved),
            published: Set(information.published),
            modified: Set(information.modified),
            withdrawn: Set(information.withdrawn),
            cwes: Set(information.cwes),
        };

        let result = vulnerability::Entity::insert(entity)
            .on_conflict(on_conflict)
            .exec_with_returning(db)
            .await?;

        Ok(VulnerabilityContext::new(self, result))
    }

    #[instrument(skip(self, connection), err(level=tracing::Level::INFO))]
    pub async fn get_vulnerability<C: ConnectionTrait>(
        &self,
        identifier: &str,
        connection: &C,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
            .map(|vuln| VulnerabilityContext::new(self, vuln)))
    }

    #[instrument(skip(self, connection), err(level=tracing::Level::INFO))]
    pub async fn get_vulnerabilities<C: ConnectionTrait>(
        &self,
        connection: &C,
    ) -> Result<Vec<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find()
            .all(connection)
            .await?
            .into_iter()
            .map(|vulnerability| VulnerabilityContext::new(self, vulnerability))
            .collect())
    }
}

#[derive(Clone)]
pub struct VulnerabilityContext {
    pub graph: Graph,
    pub vulnerability: vulnerability::Model,
}

impl Debug for VulnerabilityContext {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.vulnerability.fmt(f)
    }
}

impl VulnerabilityContext {
    pub fn new(graph: &Graph, vulnerability: vulnerability::Model) -> Self {
        Self {
            graph: graph.clone(),
            vulnerability,
        }
    }

    pub async fn advisories<C: ConnectionTrait>(
        &self,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Vec<AdvisoryContext>, Error> {
        Ok(advisory::Entity::find()
            .with_deprecation(deprecation)
            .join(
                JoinType::Join,
                advisory_vulnerability::Relation::Advisory.def().rev(),
            )
            .filter(
                advisory_vulnerability::Column::VulnerabilityId.eq(self.vulnerability.id.clone()),
            )
            .all(connection)
            .await?
            .into_iter()
            .map(|advisory| AdvisoryContext::new(&self.graph, advisory))
            .collect())
    }

    pub async fn add_description<C: ConnectionTrait>(
        &self,
        advisory: Uuid,
        lang: &str,
        description: &str,
        connection: &C,
    ) -> Result<(), Error> {
        self.add_descriptions(advisory, [(lang, description)], connection)
            .await
    }

    pub async fn add_descriptions<C: ConnectionTrait>(
        &self,
        advisory: Uuid,
        descriptions: impl IntoIterator<Item = (&str, &str)>,
        connection: &C,
    ) -> Result<(), Error> {
        let entries = descriptions.into_iter().map(|(lang, description)| {
            vulnerability_description::ActiveModel {
                id: Default::default(),
                advisory_id: Set(advisory),
                vulnerability_id: Set(self.vulnerability.id.clone()),
                lang: Set(lang.to_string()),
                description: Set(description.to_string()),
            }
        });

        for batch in &entries.chunked() {
            vulnerability_description::Entity::insert_many(batch)
                .exec(connection)
                .await?;
        }

        Ok(())
    }

    pub async fn drop_descriptions_for_advisory<C: ConnectionTrait>(
        &self,
        advisory: Uuid,
        connection: &C,
    ) -> Result<(), Error> {
        vulnerability_description::Entity::delete_many()
            .filter(vulnerability_description::Column::AdvisoryId.eq(advisory))
            .exec(connection)
            .await?;

        Ok(())
    }

    // Get all descriptions for a vulnerability
    pub async fn descriptions<C: ConnectionTrait>(
        &self,
        lang: &str,
        connection: &C,
    ) -> Result<Vec<String>, Error> {
        Ok(self
            .vulnerability
            .find_related(vulnerability_description::Entity)
            .filter(vulnerability_description::Column::Lang.eq(lang))
            .all(connection)
            .await?
            .into_iter()
            .map(|e| e.description)
            .collect())
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use crate::graph::Graph;
    use test_context::test_context;
    use test_log::test;
    use trustify_common::hashing::Digests;
    use trustify_test_context::TrustifyContext;

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn ingest_cves(ctx: TrustifyContext) -> Result<(), anyhow::Error> {
        let system = Graph::new(ctx.db.clone());

        let cve1 = system.ingest_vulnerability("CVE-123", (), &ctx.db).await?;
        let cve2 = system.ingest_vulnerability("CVE-123", (), &ctx.db).await?;
        let cve3 = system.ingest_vulnerability("CVE-456", (), &ctx.db).await?;

        assert_eq!(cve1.vulnerability.id, cve2.vulnerability.id);
        assert_ne!(cve1.vulnerability.id, cve3.vulnerability.id);

        let not_found = system.get_vulnerability("CVE-NOT_FOUND", &ctx.db).await?;

        assert!(not_found.is_none());

        Ok(())
    }

    #[test_context(TrustifyContext, skip_teardown)]
    #[test(tokio::test)]
    async fn get_advisories_from_cve(ctx: TrustifyContext) -> Result<(), anyhow::Error> {
        let advisory1 = ctx
            .graph
            .ingest_advisory(
                "GHSA-1",
                ("source", "http://ghsa.io/GHSA-1"),
                &Digests::digest("GHSA-1"),
                (),
                &ctx.db,
            )
            .await?;

        let advisory2 = ctx
            .graph
            .ingest_advisory(
                "RHSA-1",
                ("source", "http://rhsa.io/RHSA-1"),
                &Digests::digest("RHSA-1"),
                (),
                &ctx.db,
            )
            .await?;

        let _advisory3 = ctx
            .graph
            .ingest_advisory(
                "SNYK-1",
                ("source", "http://snyk.io/SNYK-1"),
                &Digests::digest("SNYK-1"),
                (),
                &ctx.db,
            )
            .await?;

        advisory1
            .link_to_vulnerability("CVE-8675309", None, &ctx.db)
            .await?;

        advisory2
            .link_to_vulnerability("CVE-8675309", None, &ctx.db)
            .await?;

        ctx.graph
            .ingest_vulnerability("CVE-8675309", (), &ctx.db)
            .await?;

        let cve = ctx.graph.get_vulnerability("CVE-8675309", &ctx.db).await?;

        assert!(cve.is_some(), "there should be some CVE");

        let cve = cve.unwrap();

        let linked_advisories = cve.advisories(Default::default(), &ctx.db).await?;

        assert_eq!(2, linked_advisories.len());

        assert!(linked_advisories.contains(&advisory1));
        assert!(linked_advisories.contains(&advisory2));

        Ok(())
    }
}
